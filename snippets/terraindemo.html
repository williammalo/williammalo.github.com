
<!DOCTYPE html>
<meta charset="utf-8">
<title>terrain test</title>
<style>canvas{width:960px;position:relative;z-index:1;}img{position:absolute;}</style>
<body>
<img src = 'imagest/level.png'            >
<img src = 'imagest/playerr.png'          >
<img src = 'imagest/playerl.png'          >
<img src = 'imagest/player-collision.png' >
<script>
//chainvas
(function(){var e=window.Chainvas={chainable:function(a){return function(){var b=a.apply(this,arguments);return b===void 0?this:b}},chainablizeOne:function(a,b){try{e.utils.hasOwnProperty(a,b)&&e.utils.isFunction(a[b])&&(a[b]=e.chainable(a[b]))}catch(c){}return this},chainablize:function(a,b){var c=a.prototype;if(b)for(var d=b.length;d--;)e.chainablizeOne(c,b[d]);else for(d in c)e.chainablizeOne(c,d);return this},helpers:function(a,b){var c=a.prototype,d;for(d in e.methods)c&&!(d in c)&&(c[d]=e.methods[d]);e.extend(c,b);return this},extend:function(a,b){return Chainvas.methods.prop.call(a,b)},global:function(a,b,c){typeof a==="string"&&(a=[a]);for(var d=a.length;d--;){var f=window[a[d]];f&&e.chainablize(f,c).helpers(f,b)}},methods:{prop:function(){if(arguments.length===1){var a=arguments[0],b;for(b in a)this[b]=a[b]}else arguments.length===2&&(this[arguments[0]]=arguments[1]);return this}},utils:{isFunction:function(a){var b=Object.prototype.toString.call(a);return b==="[object Function]"||b==="[object Object]"&& "call"in a&&"apply"in a&&/^\s*\bfunction\s+\w+\([\w,]*\) \{/.test(a+"")},hasOwnProperty:function(a,b){try{return a.hasOwnProperty(b)}catch(c){return b in a&&(!a.prototype||!(b in a.prototype)||a.prototype[b]!==a[b])}}}}})();
Chainvas.chainablize(Element)
Chainvas.helpers(Element)
Chainvas.chainablize(CanvasRenderingContext2D)
Chainvas.helpers(CanvasRenderingContext2D)

//allows use of Math functions in global scope https://gist.github.com/2221488
;(function(a,b){for(b in a=Object.getOwnPropertyNames(Math))this[a[b]]=Math[a[b]]})()
//useful math functions:
Math.sign = Math.sign || function(x) {
  x = +x; // convert to a number
  if (x === 0 || isNaN(x)) {
    return x;
  }
  return x > 0 ? 1 : -1;
}
var sign = Math.sign;

//
var imgToMap = function(img,a,i){
	var hitMap=[];
	var w=img.width,h=img.height;
	a=document.createElement("canvas").prop({width:w,height:h}).getContext("2d").drawImage(img,0,0).getImageData(0,0,w,h).data;

	for(i=0;i<w*h;i++) hitMap[i]=a[i<<2]<128
	hitMap.w=w;
	hitMap.h=h;
	return hitMap
};


//key press handling
var key={
	left  : false,
	right : false,
	space : false,
	up    : false,
	down  : false
}

;(function(foo){
	onkeydown = function(e){foo(true,e)}
	onkeyup   = function(e){foo(false,e)}

	foo=function(a,e){
		key[{
			37 : "left",
			39 : "right",
			32 : "space",
			38 : "up",
			40 : "down"
		}[e.keyCode]]=a
	}
})()


//only initialize game ounce images have loaded
onload=function(){

	//global variables
	var w=480, h=320, FPS = 30, scaling=2;

	var defaultDraw = function(){
		canvas.drawImage(
			 this.image
			,(this.x|0)*scaling
			,(this.y|0)*scaling
			,this.w*scaling
			,this.h*scaling
		)
	}

	//images
	var
	 levelimg     = document.images[0]
	,playerr      = document.images[1]
	,playerl      = document.images[2]
	,playerHitImg = document.images[3];


	var level={
		 x     : 0
		,y     : 0
		,w     : 480
		,h     : 320
		,hit   : imgToMap(levelimg)
		,image : levelimg
		,draw  : defaultDraw
	};

	//collision detection with level terrain


	var collides = function(o1,o2,xoff,yoff){

		xoff |= 0 //offset of object 2 (optional)
		yoff |= 0 

		var ᑎx, ᑎy, ᑎx2, ᑎy2, ᑎw, ᑎh, ᑎA, i, ix, iy, ix1, iy1, ix2, iy2;
        
        // check if two objects intersect (ᑎ)
		ᑎx  = max( o1.x , o2.x+xoff );
		ᑎy  = max( o1.y , o2.y+yoff );
    	ᑎx2 = min( o1.x+o1.w , o2.x+xoff+o2.w );
	    ᑎy2 = min( o1.y+o1.h , o2.y+yoff+o2.h );

	    if (ᑎx2 > ᑎx && ᑎy2 > ᑎy) {

            ᑎw = ᑎx2 - ᑎx;
            ᑎh = ᑎy2 - ᑎy;
            ᑎA = ᑎw * ᑎh;

			for(i=0;i<ᑎA;i++){// check every pixel inside ᑎ for collision

				// position of iterator
				ix = ( i%ᑎw )
				iy = (i/ᑎw|0)
				// position of iterator inside o1
				ix1 = ix - (o1.x - ᑎx);
				iy1 = iy - (o1.y - ᑎy);
				// position of iterator inside o2
				ix2 = ix - (o2.x+xoff - ᑎx);
				iy2 = iy - (o2.y+yoff - ᑎy); 

				if( o1.hit[ iy1*o1.w+ix1 ] & o2.hit[ iy2*o2.w+ix2 ] ) return 1
				
			}
	    }
	    return 0;
	}

	var player={
		 x     : 180
		,y     : 150
		,w     : playerr.width
		,h     : playerr.height
		,yυ    : 0
		,image : playerr
		,hit   : imgToMap(playerHitImg)

		,move: function(x,y){
			var a=false;
			if(!collides(level,this,x,y)){
				this.x += x;
				this.y += y;
				a=true;
			}
			return a
		}
		,update: function(){
			//move left or right
			var direction = key.right-key.left;
			if(direction){
				this.move(3*direction,0)||this.move(2*direction,-1)||this.move(direction,-2)
				this.image=~direction?playerr:playerl
			}

			//jump if character is on floor and doesn't have ceiling over it.
			if(key.up&&collides(level,this,0,1)&&!collides(level,this,0,-8))this.yυ=-9
			
			//pixel perfect vertical movement
			for(var i=abs(this.yυ);i--;)this.move(0, sign(this.yυ))

			//gravity
			this.yυ += 1
			if(collides(level,this,0,1))this.yυ=0

		}
		,draw: defaultDraw
	}


		setInterval(function(){

			player.update()
			canvas
				.clearRect(0,0,w*scaling,h*scaling)

			level.draw()
			player.draw()


		},1e3/FPS)

		//create the actual canvas
		canvas=document.body.appendChild(
			document.createElement("canvas")
				.prop({ width:w*scaling, height:h*scaling })
		).getContext("2d").prop({webkitImageSmoothingEnabled:false, mozImageSmoothingEnabled:false})
        
}
</script>

<!DOCTYPE html>
<meta charset="utf-8">
<title>WebGL HUSL</title>

<style>
    [hidden]{display:none;}
    .menu-open canvas{
        cursor:pointer
    }
    .click-target{
        cursor:pointer
    }
    .color-menu{
        position:relative;
        width:100px;
        pointer-events:none;
    }
    .click-target{
        position:absolute;
        top:42px;
        left:42px;
        width:16px;
        height:16px;
        border-radius:50%;
        pointer-events:initial
    }
    .menu-open canvas{
        pointer-events:initial
    }
</style>

<h1>Click the Colored Circle</h1>
<div class="color-menu" id="color-menu">
    <canvas id="canvas" width="200" height="200" style="width:100px;height:100px;transform:translateZ(0);border-radius:50%"></canvas>
    <div class="click-target"></div>
</div>



<script id="2d-vertex-shader" type="x-shader/x-vertex">

precision lowp float;

attribute vec2 a_position;
uniform vec2 u_resolution;

uniform float animationProgress;

varying vec2 pixelPosition;

varying float smoothness;

void main() {

  vec2 position = (a_position+1.0)*0.5;
  position.y = 1.0-position.y;
  pixelPosition = position*u_resolution;

  smoothness=max((.5-abs(.5-animationProgress))*30.0+animationProgress*10.0,2.0);


  gl_Position = vec4(a_position,0,1);
}
</script>

<script id="2d-fragment-shader" type="x-shader/x-fragment">
precision lowp float;

uniform vec2 u_resolution;

varying vec2 pixelPosition;

uniform float animationProgress;
varying float smoothness;

uniform vec3 currentColor;

float tau=6.28318;


vec4 circle(vec3 color,vec2 p,float r) {
    p=p-pixelPosition;
    return vec4(color,
        //easing function
            //prevent values lower than 0 (negative alpha can't exist)
                //reverse distance function and set width of blur
                    //actual distance function
        pow(
            max(
                1.-(
                    max(length(p) - r,0.)
                )/smoothness
            ,0.0)
        ,2.)
    );
}

vec4 box( vec3 color,vec2 p, vec2 b ) {
    p=p-pixelPosition;
    return vec4(color,pow(max(1.-(
        length(max(abs(p)-b,0.))
    )/smoothness,0.0),2.));
}

vec4 roundBox(vec3 color, vec2 p, vec2 b, float r ) {
    p=p-pixelPosition;
    return vec4(color,pow(max(1.-(
        length(max(abs(p)-(b-vec2(r)),0.))-r
    )/smoothness,0.0),2.));
}


vec4 colorMix(vec4 a, vec4 b){
    float foo=a.a/(a.a+b.a);

    // fix divide by zero errors
    if(a.a+b.a<=.0){ foo=.5; }

    return vec4(
        mix( b.rgb, a.rgb, foo ),
        a.a+b.a
    );
}

vec4 aThreshold(vec4 a){
    a.a = 1. - (1.-a.a)*smoothness/2.;
    a.a = clamp(a.a,0.,1.);
    return a;
}

vec2 lengthDir(float dist,float dir){
    //return vec2(cos(dir),sin(dir))*dist;
    return sin( vec2(dir+tau/4.0,dir) )*dist;
}


void main() {

    vec2 center = u_resolution/2.0;

    vec4 objects[16];

    vec3 colors[8];

    colors[0] = vec3( 207, 140, 227 );
    colors[1] = vec3( 240, 134, 184 );
    colors[2] = vec3( 251, 167, 139 );
    colors[3] = vec3( 236, 212, 116 );
    colors[4] = vec3( 168, 229, 135 );
    colors[5] = vec3(  70, 238, 196 );
    colors[6] = vec3(  35, 225, 245 );
    colors[7] = vec3( 141, 180, 251 );

    vec3 darkC[8];

    darkC[0] = pow(mix(colors[0],vec3(0),0.2)/255.0,vec3(2.2));
    darkC[1] = pow(mix(colors[1],vec3(0),0.2)/255.0,vec3(2.2));
    darkC[2] = pow(mix(colors[2],vec3(0),0.2)/255.0,vec3(2.2));
    darkC[3] = pow(mix(colors[3],vec3(0),0.2)/255.0,vec3(2.2));
    darkC[4] = pow(mix(colors[4],vec3(0),0.2)/255.0,vec3(2.2));
    darkC[5] = pow(mix(colors[5],vec3(0),0.2)/255.0,vec3(2.2));
    darkC[6] = pow(mix(colors[6],vec3(0),0.2)/255.0,vec3(2.2));
    darkC[7] = pow(mix(colors[7],vec3(0),0.2)/255.0,vec3(2.2));

    colors[0] = pow(colors[0]/255.0,vec3(2.2));
    colors[1] = pow(colors[1]/255.0,vec3(2.2));
    colors[2] = pow(colors[2]/255.0,vec3(2.2));
    colors[3] = pow(colors[3]/255.0,vec3(2.2));
    colors[4] = pow(colors[4]/255.0,vec3(2.2));
    colors[5] = pow(colors[5]/255.0,vec3(2.2));
    colors[6] = pow(colors[6]/255.0,vec3(2.2));
    colors[7] = pow(colors[7]/255.0,vec3(2.2));

    vec3 currentColorL = pow(currentColor/255.0,vec3(2.2));
    vec3 currentDarkL = pow(mix(currentColor,vec3(0),0.2)/255.0,vec3(2.2));
    

    objects[0]=circle(
            mix(currentDarkL,darkC[0],animationProgress),
            center+lengthDir( animationProgress*60.0, float(0)*(tau/8.0) ),
            16.
        );
    objects[1]=circle(
            mix(currentDarkL,darkC[1],animationProgress),
            center+lengthDir( animationProgress*60.0, float(1)*(tau/8.0) ),
            16.
        );
    objects[2]=circle(
            mix(currentDarkL,darkC[2],animationProgress),
            center+lengthDir( animationProgress*60.0, float(2)*(tau/8.0) ),
            16.
        );
    objects[3]=circle(
            mix(currentDarkL,darkC[3],animationProgress),
            center+lengthDir( animationProgress*60.0, float(3)*(tau/8.0) ),
            16.
        );
    objects[4]=circle(
            mix(currentDarkL,darkC[4],animationProgress),
            center+lengthDir( animationProgress*60.0, float(4)*(tau/8.0) ),
            16.
        );
    objects[5]=circle(
            mix(currentDarkL,darkC[5],animationProgress),
            center+lengthDir( animationProgress*60.0, float(5)*(tau/8.0) ),
            16.
        );
    objects[6]=circle(
            mix(currentDarkL,darkC[6],animationProgress),
            center+lengthDir( animationProgress*60.0, float(6)*(tau/8.0) ),
            16.
        );
    objects[7]=circle(
            mix(currentDarkL,darkC[7],animationProgress),
            center+lengthDir( animationProgress*60.0, float(7)*(tau/8.0) ),
            16.
        );

 /*   for(int i=0;i<8;i++){

        objects[i]=circle(
            mix(currentDarkL,darkC[i],animationProgress),
            center+lengthDir( animationProgress*60.0, float(i)*(tau/8.0) ),
            16.
        );
        objects[i+8]=circle(
            mix(currentColorL,colors[i],animationProgress),
            center+lengthDir( animationProgress*60.0, float(i)*(tau/8.0) ),
            12.
        );
    }*/

    objects[8]=circle(
            mix(currentColorL,colors[0],animationProgress),
            center+lengthDir( animationProgress*60.0, float(0)*(tau/8.0) ),
            12.
        );
    objects[9]=circle(
            mix(currentColorL,colors[1],animationProgress),
            center+lengthDir( animationProgress*60.0, float(1)*(tau/8.0) ),
            12.
        );
    objects[10]=circle(
            mix(currentColorL,colors[2],animationProgress),
            center+lengthDir( animationProgress*60.0, float(2)*(tau/8.0) ),
            12.
        );
    objects[11]=circle(
            mix(currentColorL,colors[3],animationProgress),
            center+lengthDir( animationProgress*60.0, float(3)*(tau/8.0) ),
            12.
        );
    objects[12]=circle(
            mix(currentColorL,colors[4],animationProgress),
            center+lengthDir( animationProgress*60.0, float(4)*(tau/8.0) ),
            12.
        );
    objects[13]=circle(
            mix(currentColorL,colors[5],animationProgress),
            center+lengthDir( animationProgress*60.0, float(5)*(tau/8.0) ),
            12.
        );
    objects[14]=circle(
            mix(currentColorL,colors[6],animationProgress),
            center+lengthDir( animationProgress*60.0, float(6)*(tau/8.0) ),
            12.
        );
    objects[15]=circle(
            mix(currentColorL,colors[7],animationProgress),
            center+lengthDir( animationProgress*60.0, float(7)*(tau/8.0) ),
            12.
        );


    vec4 color = objects[0];

    color=colorMix(color,objects[1]);
    color=colorMix(color,objects[2]);
    color=colorMix(color,objects[3]);
    color=colorMix(color,objects[4]);
    color=colorMix(color,objects[5]);
    color=colorMix(color,objects[6]);
    color=colorMix(color,objects[7]);
    
  
    color = aThreshold(color);

    vec4 layer2 = objects[8];

    layer2=colorMix(layer2,objects[9]);
    layer2=colorMix(layer2,objects[10]);
    layer2=colorMix(layer2,objects[11]);
    layer2=colorMix(layer2,objects[12]);
    layer2=colorMix(layer2,objects[13]);
    layer2=colorMix(layer2,objects[14]);
    layer2=colorMix(layer2,objects[15]);
    
    layer2 = aThreshold(layer2);

    //add layer 2
    color.rgb=mix(color.rgb,    layer2.rgb,    layer2.a);


  
    //gamma correct
    color.rgb=pow(color.rgb,vec3(1.0/2.2));

    gl_FragColor = color;
    
    //gl_FragColor = vec4(0,0,1,1);
}
</script>


<script>
"use strict";


function createShaderFromScript(gl, scriptId) {
  var shaderType;
  var shaderScript = document.getElementById(scriptId);

  var shaderSource = shaderScript.text;


  if (shaderScript.type === "x-shader/x-vertex") {
    shaderType = gl.VERTEX_SHADER;
  } else if (shaderScript.type === "x-shader/x-fragment") {
    shaderType = gl.FRAGMENT_SHADER;
  }

  var shader = gl.createShader(shaderType);
  gl.shaderSource(shader, shaderSource);
  gl.compileShader(shader);

  return shader;
}


function createProgramFromScripts(gl, vertexShader, fragmentShader) {


  var program = gl.createProgram();

  gl.attachShader(program, createShaderFromScript(gl, vertexShader  ) );
  gl.attachShader(program, createShaderFromScript(gl, fragmentShader) );

  gl.linkProgram(program);

  return program;
};





  var canvas = document.getElementById("canvas");

  var gl = canvas.getContext("webgl");


  var program = createProgramFromScripts(gl, "2d-vertex-shader", "2d-fragment-shader" );
  gl.useProgram(program);

  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  // position
  var positionLocation = gl.getAttribLocation(program, "a_position");

  // resolution
  var resolutionLocation = gl.getUniformLocation(program, "u_resolution");
  gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

  // color1
  var c1Location = gl.getUniformLocation(program, "animationProgress");
  gl.uniform1f(c1Location , 0.0);

  //currentColor
  var curLocation = gl.getUniformLocation(program, "currentColor");
  gl.uniform3f(curLocation, 70, 238, 196);


  var buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1.0, -1.0,
         1.0, -1.0,
        -1.0,  1.0,
        -1.0,  1.0,
         1.0, -1.0,
         1.0,  1.0]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);





  var menuOpen=false;
  var animationProgress=0;
  var clamp=function(a,b,c){
    return Math.max(b,Math.min(c,a));
  }
  var colorMenu = document.getElementById("color-menu")

  colorMenu.onclick=function(e){
    if(menuOpen){
        var tau=6.28318;
        var x=(e.clientX-colorMenu.offsetLeft)
        var y=(e.clientY-colorMenu.offsetTop)
        var direction = (Math.atan2(50-x,50-y)+tau)%tau
        var colorI=Math.round((direction/tau)*8);
        var colors=[
            [207, 140, 227],
            [240, 134, 184],
            [251, 167, 139],
            [236, 212, 116],
            [168, 229, 135],
            [ 70, 238, 196],
            [ 35, 225, 245],
            [141, 180, 251]
        ]
        var color=colors[(14-colorI)%8];
        gl.uniform3f(curLocation, color[0], color[1], color[2]);
        colorMenu.classList.remove("menu-open")
    }
    if(!menuOpen){
        colorMenu.classList.add("menu-open")
    }
    menuOpen=!menuOpen;
  }

  var easeInOut= function (t) { return t<.5 ? 2*t*t : -1+(4-2*t)*t }

  requestAnimationFrame(function f(){
        var stepSize=((1/60)/.5)*(menuOpen?1:-1);

        animationProgress=clamp(animationProgress+stepSize,0,1)

        gl.uniform1f(c1Location , easeInOut(animationProgress) );  
        //gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(f)
  })










</script>

